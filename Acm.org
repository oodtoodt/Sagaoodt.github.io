
* 2017
** 2017-03 March
*** 2017-03-03 Friday
**** CF-363D
迷啊。从test3到test5、test6、test8，这个题我已经快疯掉了。
test3是特殊0，0，test5是两个给定数据取小值，test6是左右边界，test8，淦，终于做到test8了，淦淦淦。test半小时了。

Entered on [2017-03-03 Fri 16:03]  

Ended on [2017-03-03 Fri 16:06]
**** 我找到问题了！
其实是二分到最后的时候：
mid = true，l = mid + 1，此时l == r，mid = l/r ，true 则向右，否则向左，但是根本捕捉不到这个最后true还是false。向右则取此时的mid值，向左则取左值（移动过的r值）
其实还有一种情况，mid = false，r = mid - 1，直接把l越过此时取左值（移动过的r值）
所以哦，淦。
看题解去了！淦！
二分在界点，在分类上有各种各样的形式。。。
比如
***** 代码
while(l <= r)
    {
        mid = (r + l) / 2;
        if(ok(mid,a,n))
        {
            l = mid + 1;
        }
        else
        {
            r = mid - 1;
        }
    }
    再比如
***** 代码
      while(l < r)
      {
          int mid = r - (r - l) / 2;//这里的技巧是取两数中间靠右的数。
          if(cal(mid) >= 0)  l = mid;
          else r = mid - 1;
      }
取l值
该死的二分，我再去看看。

Entered on [2017-03-03 Fri 16:20]  

Ended on [2017-03-03 Fri 16:31]
**** 尴尬
我上git上看了下，这个空行的问题比较严重\n
所以呢。就是做一个自己的日记形式的，不是题解咯，写一点思路，写一点收获。
**** 失智了失智了！
连续错在test8.我已经修正了边界的问题了啊。

Entered on [2017-03-03 Fri 16:54]  

Ended on [2017-03-03 Fri 16:54]
**** 淦
原来根本和边界没关系啊= =淦。两种写法应该只是个人习惯吧。上一种返回l-1就好了。
是最后一个判断判断错了而已。。。

Entered on [2017-03-03 Fri 17:31]  

Ended on [2017-03-03 Fri 17:31]
**** 第二次训练
***** G-GCD Again：欧拉函数？？？喵喵喵？
****** 函数
int eular_pui(int n)
{
    int m =sqrt(n+0.5);
    int ans = n;
    for(int i = 0; i < m; i++)
    {
         if(n%i==0)
             ans=ans/i*(i-1);
         while(n%i==0)
             n/=i;
    }
    if(n>1) ans=ans/n*(n-1)
    return ans;
}
迷之容斥原理。
***** B-boxes：看差。
111 n-1 到了222-3-3那一步之后，再全体-2（因为走了两波要走两次）
然后全部为0或者全部为n的倍数
***** C-just a joke 
= =迷之。大学物理。
***** D-
暴力模拟
***** E-
先读cg，读d【i】读w【i】dp[0][MID]=1
for(int i =1;i<=g;i++)
   for(int j =0;j<M;j++)
      if(dp[i-1][j])//优化
         for(int k=1;k<=c;k++)
            dp[i][j+w[i]*d[k]]+=dp[i-1][j]
printf("%d",dp[g][MID]);
***** F-
map
读进人名，做一个map。
f[i][j]0/1 第i句话由第j个人说。0不可能。
g[i][j]0/1/k
把话都塞进一个set
是？号，枚举所有可能。
*** 2017-03-09 Thursday
**** 3个h血的教训
二分的时候有的时候是需要一个左值的。毕竟不麻烦。
主要是。
l+r／2的时候取得的值远远不如一个单值，如果是求跟多个值有关可能会非常崩。比如这次，最大值最小化，mid远不如单值。我举个例子吧。
1 2 1 2 90
可能不是很恰当，反正就是取到90炸了之后，就把90跳过去了！然后取2121发现啊唷居然小，然后就往小里取了！就往小里取了！方向就从向右掉头永久向左，真tm气

Entered on [2017-03-09 Thu 22:24]  

Ended on [2017-03-09 Thu 22:24]
*** 2017-03-10 Friday
**** 
***** A
普通dp，（大家都做出来了TAT）
T[i]=min(t[i-1]+t[i],t[i-2]+d[i]);
滚一圈就可以了。
***** B
三角形状》？？我日整个题读错无fk说。。一共就做了这一道无怪乎做不出来。gggg。
我tm以为直接排列，前后递增子序列无fk说。
nlogn n^2 .
****** 记题啦
int pre[N],suf[N]

...
读取。
memset(0xef)
for(int i = 0;i<n;i++)
{
   int pos = lower_bound(dp,dp+n,l[i])-dp;
   dp[pos]=l[i];
   pre[i]=pos;
}
memset(dp,0x3f)
倒序再来一遍
dp[pos] = l[i]
suf[i]=pos;

int mins = INF (=0x3f3f3f3f)
for(int i )
   for(int j = i + 1; j < n; j++)
   {
      mins = min(mins,n-pre[i]-suf[i]-1)
   }
...然后迷之不对。。反正思路是二分。




Entered on [2017-03-10 Fri 20:42]  

Ended on [2017-03-10 Fri 20:42]
推荐用int，又不能直接乘，最好是字符串
***** C
状压dp。
无fk说。gg
dp[i][j] =  
淦，听都没听懂。
****** 以下天书
dp[i][j]= 第i轮
dp[3][110111]=3说明方案数3
dp[4][111111]
j循环后层。
x=j&a[i+1]^a[i+1]能插几个
a[4]=101111
100111dp[i+1][j|k]=dp[i][j];
插一个蜡烛在k


第二遍算是简单的了解了一点。
（似乎是）知道了状压是个什么鬼。
**** 

Entered on [2017-03-10 Fri 21:08]  

Ended on [2017-03-10 Fri 21:08]
*** 2017-03-14 Tuesday
**** 周二
***** F
      dijkstra....= =
***** A
***** C
环 bellmanford...= =
***** D
最小生成树 把费用/长度设置成0就行。 kruskal....= =
***** E
a引爆b则a到b的有向边。
qiangjienuosiliang？
rudu为0


Entered on [2017-03-14 Tue 20:38]  

Ended on [2017-03-14 Tue 20:38]

