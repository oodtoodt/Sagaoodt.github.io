
* 2017
** 2017-03 March
*** 2017-03-03 Friday
**** CF-363D
迷啊。从test3到test5、test6、test8，这个题我已经快疯掉了。
test3是特殊0，0，test5是两个给定数据取小值，test6是左右边界，test8，淦，终于做到test8了，淦淦淦。test半小时了。

Entered on [2017-03-03 Fri 16:03]  

Ended on [2017-03-03 Fri 16:06]
**** 我找到问题了！
其实是二分到最后的时候：
mid = true，l = mid + 1，此时l == r，mid = l/r ，true 则向右，否则向左，但是根本捕捉不到这个最后true还是false。向右则取此时的mid值，向左则取左值（移动过的r值）
其实还有一种情况，mid = false，r = mid - 1，直接把l越过此时取左值（移动过的r值）
所以哦，淦。
看题解去了！淦！
二分在界点，在分类上有各种各样的形式。。。
比如
***** 代码
while(l <= r)
    {
        mid = (r + l) / 2;
        if(ok(mid,a,n))
        {
            l = mid + 1;
        }
        else
        {
            r = mid - 1;
        }
    }
    再比如
***** 代码
      while(l < r)
      {
          int mid = r - (r - l) / 2;//这里的技巧是取两数中间靠右的数。
          if(cal(mid) >= 0)  l = mid;
          else r = mid - 1;
      }
取l值
该死的二分，我再去看看。

Entered on [2017-03-03 Fri 16:20]  

Ended on [2017-03-03 Fri 16:31]
**** 尴尬
我上git上看了下，这个空行的问题比较严重\n
所以呢。就是做一个自己的日记形式的，不是题解咯，写一点思路，写一点收获。
**** 失智了失智了！
连续错在test8.我已经修正了边界的问题了啊。

Entered on [2017-03-03 Fri 16:54]  

Ended on [2017-03-03 Fri 16:54]
**** 淦
原来根本和边界没关系啊= =淦。两种写法应该只是个人习惯吧。上一种返回l-1就好了。
是最后一个判断判断错了而已。。。

Entered on [2017-03-03 Fri 17:31]  

Ended on [2017-03-03 Fri 17:31]
**** 第二次训练
***** G-GCD Again：欧拉函数？？？喵喵喵？
****** 函数
int eular_pui(int n)
{
    int m =sqrt(n+0.5);
    int ans = n;
    for(int i = 0; i < m; i++)
    {
         if(n%i==0)
             ans=ans/i*(i-1);
         while(n%i==0)
             n/=i;
    }
    if(n>1) ans=ans/n*(n-1)
    return ans;
}
迷之容斥原理。
***** B-boxes：看差。
111 n-1 到了222-3-3那一步之后，再全体-2（因为走了两波要走两次）
然后全部为0或者全部为n的倍数
***** C-just a joke 
= =迷之。大学物理。
***** D-
暴力模拟
***** E-
先读cg，读d【i】读w【i】dp[0][MID]=1
for(int i =1;i<=g;i++)
   for(int j =0;j<M;j++)
      if(dp[i-1][j])//优化
         for(int k=1;k<=c;k++)
            dp[i][j+w[i]*d[k]]+=dp[i-1][j]
printf("%d",dp[g][MID]);
***** F-
map
读进人名，做一个map。
f[i][j]0/1 第i句话由第j个人说。0不可能。
g[i][j]0/1/k
把话都塞进一个set
是？号，枚举所有可能。
*** 2017-03-09 Thursday
**** 3个h血的教训
二分的时候有的时候是需要一个左值的。毕竟不麻烦。
主要是。
l+r／2的时候取得的值远远不如一个单值，如果是求跟多个值有关可能会非常崩。比如这次，最大值最小化，mid远不如单值。我举个例子吧。
1 2 1 2 90
可能不是很恰当，反正就是取到90炸了之后，就把90跳过去了！然后取2121发现啊唷居然小，然后就往小里取了！就往小里取了！方向就从向右掉头永久向左，真tm气

Entered on [2017-03-09 Thu 22:24]  

Ended on [2017-03-09 Thu 22:24]
*** 2017-03-10 Friday
**** 
***** A
普通dp，（大家都做出来了TAT）
T[i]=min(t[i-1]+t[i],t[i-2]+d[i]);
滚一圈就可以了。
***** B
三角形状》？？我日整个题读错无fk说。。一共就做了这一道无怪乎做不出来。gggg。
我tm以为直接排列，前后递增子序列无fk说。
nlogn n^2 .
****** 记题啦
int pre[N],suf[N]

...
读取。
memset(0xef)
for(int i = 0;i<n;i++)
{
   int pos = lower_bound(dp,dp+n,l[i])-dp;
   dp[pos]=l[i];
   pre[i]=pos;
}
memset(dp,0x3f)
倒序再来一遍
dp[pos] = l[i]
suf[i]=pos;

int mins = INF (=0x3f3f3f3f)
for(int i )
   for(int j = i + 1; j < n; j++)
   {
      mins = min(mins,n-pre[i]-suf[i]-1)
   }
...然后迷之不对。。反正思路是二分。




Entered on [2017-03-10 Fri 20:42]  

Ended on [2017-03-10 Fri 20:42]
推荐用int，又不能直接乘，最好是字符串
***** C
状压dp。
无fk说。gg
dp[i][j] =  
淦，听都没听懂。
****** 以下天书
dp[i][j]= 第i轮
dp[3][110111]=3说明方案数3
dp[4][111111]
j循环后层。
x=j&a[i+1]^a[i+1]能插几个
a[4]=101111
100111dp[i+1][j|k]=dp[i][j];
插一个蜡烛在k


第二遍算是简单的了解了一点。
（似乎是）知道了状压是个什么鬼。
**** 

Entered on [2017-03-10 Fri 21:08]  

Ended on [2017-03-10 Fri 21:08]
*** 2017-03-14 Tuesday
**** 周二
***** F
      dijkstra....= =
***** A
***** C
环 bellmanford...= =
***** D
最小生成树 把费用/长度设置成0就行。 kruskal....= =
***** E
a引爆b则a到b的有向边。
qiangjienuosiliang？
rudu为0


Entered on [2017-03-14 Tue 20:38]  

Ended on [2017-03-14 Tue 20:38]
*** 2017-03-17 Friday
**** graph2
真够。
***** A
强连通分量
跑一遍就好了
***** B
floyd n^3传递（闭包？）
两重dfs
***** C
并查集
父亲界点
***** D
二分图匹配
放法是每行每列只能一个
横坐标左边列，纵坐标右边列
二分图最大匹配 最多棋子。
枚举每个点，....fk跟不上了
***** E
裸最大流





Entered on [2017-03-17 Fri 19:23]  
Ended on [2017-03-17 Fri 20:45]
*** 2017-03-21 Tuesday
**** 6概率和期望

***** D
d[i]=(1-p)d[i-2]+pd[i-1]
[d[i],d[i-1]]=[p,1;1-p,0][d[i-1],d[i-2]]
在第二个矩阵加幂，快速幂。
矩阵快速幂
***** E
化成方程组，高斯消元
***** C
据说是玄学题，没听懂
***** B

***** A
典型的期望题。
求期望的时候从后往前求，求概率从前往后求。
d[n][s]=0
d[i][j]....


Entered on [2017-03-21 Tue 20:38]  
Ended on
*** 2017-03-28 Tuesday
**** 第七次-字符串

***** A
get读入。相同就ac 不相同，先去掉' ' '\t' '\n'再比较。
我是做复杂了= =判断做多了
可以把去掉的和没去掉的用两个字符串来表示。
还有gets到空行时似乎会跳过，此时用ans来判断，然后加空行。
***** B
p[s1[i]-'a'+1]=s2[i]-'a'+1;
p[s2[i]-'a'+1]=s1[i]-'a'+1;
不是很懂，回去看题解吧
***** C
KMP NXT数组
***** D
最大回文子串的一种算法
Manacher O(n)
***** E
扩展kmp


Entered on [2017-03-28 Tue 20:34]  
Ended on [2017-03-28 Tue 21:20]
*** 2017-03-31 Friday
**** 第八次
- A
贪心
用正数而不是用负数做判断。k-m是没问题的。
求出所有连续的正数，对它排序，从小到大依次减去
- B
我tm可能是中了毒。我居然看到回文串就想到n^2 n^3 和 n ，然后就把题跳过去了。。明明那些是最长回文子序列...
没救了没救了。
比较复杂的map题。
- C
二分？
- D
状态压缩dp，gg
- E
并查集

Entered on [2017-03-31 Fri 20:29]  
Ended on [2017-03-31 Fri 21:45]
** 2017-04 April
*** 2017-04-10 Monday
*** 2017-04-18 Tuesday
**** 4.18
- A
前两项放在左边 然后打表（x最大50）拆项
- B
一个一个dfs
- C
并查集。。。。淦我怎么记得有过。。我就说。。看着眼熟然后大家都做出来了（graph2C 8-E）
- D
mlgj这个题可以输入一行输出一行的？？？？我擦？？
- E
并 查 集

Entered on [2017-04-18 Tue 20:33]  
Ended on [2017-04-18 Tue 20:59]
*** 2017-04-24 Monday
**** 校赛题
- A
凸包
- B
博弈树，树上博弈
- C
化为12345加法，先算能不能被整除（初步验证，并算出多少轮***对，这个最重要。。。有了轮次之后就会清晰很多，整个过程就简单了）全部为0或者为n的倍数（说起来就是个找规律。。我是规律找出来了但是没有将它清晰化，没有优化好，写得也很难。）= =（还会炸int......无fk说）
- D
暴力二分？？？
- E
另一个博弈= =
- F
分词dfs
- G
= =出题人说平常c语言的作业难度...好吧
- H
O(n)的方法：和j题的倒着的思路一样。保持一个sum(总的)和s[?l]比较迷的方法
比如3 1（有2个2 3个1）然后利用sum和sl去做。
3 1
2 3
3 6

另外一个题
1
2 12
3 23 123
4 34 234 1234
这样就可以维护一个s[l],s[l] = s[l-1]*l;然后对于重复的有一个特判
- I
切题 异或和 dp
- J
和h题一样，先排最大的（嘛。。说实话这个方法的核心和那个从里面去减的方法是一样的。）坑的地方在于有没有全给。全给的话会简单许多。不全给的话= =应该利用假设全给的情况的东西如果减去上一个得负数且下一个为空，则可以利用这个差（这个差比较key，我当时没有想到，所以没有得出来，不过这个烂题根本不需要考虑这个）推断出下一个的大小。


Entered on [2017-04-24 Mon 18:43]  
Ended on [2017-04-24 Mon 19:38]
** 2017-05 May
*** 2017-05-21 Sunday
**** 读题啊！
md两个人选礼物啊！不是背包啊！虽然张了个背包的样子啊！fk啊！淦啊！

Entered on [2017-05-21 Sun 14:42]  
Ended on [2017-05-21 Sun 14:42]
